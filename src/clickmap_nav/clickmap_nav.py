# !/usr/bin/env python

# noinspection PyUnresolvedReferences
import vtkmodules.vtkRenderingOpenGL2
from vtkmodules.vtkCommonColor import vtkNamedColors
from vtkmodules.vtkCommonCore import vtkMinimalStandardRandomSequence
from vtkmodules.vtkFiltersHybrid import vtkPolyDataSilhouette
from vtkmodules.vtkFiltersSources import vtkSphereSource
from vtkmodules.vtkInteractionStyle import vtkInteractorStyleTerrain, vtkInteractorStyleTrackballCamera
from vtkmodules.vtkRenderingCore import (
    vtkActor,
    vtkPolyDataMapper,
    vtkPropPicker,
    vtkRenderWindow,
    vtkRenderWindowInteractor,
    vtkRenderer
)
import argparse
import logging
import math
import os
import sys
import time

import numpy as np
import google.protobuf.timestamp_pb2
import sdk_examples.graph_nav_util as graph_nav_util
import grpc
import vtk
from vtk.util import numpy_support

from bosdyn.api import geometry_pb2
from bosdyn.api.graph_nav import map_pb2
from bosdyn.client.frame_helpers import *
from bosdyn.client.math_helpers import *
from bosdyn_vtk_utils import api_to_vtk_se3_pose, numpy_to_poly_data


def get_program_parameters():
    description = 'Load a map generated by spot and click on waypoints to navigate.'
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('path', type=str, help='Map to draw.', 
                        nargs='?', default='/home/arthurlovekin/spot/maps/collabspace1/') #TODO: Remove once development is over
    parser.add_argument('-a', '--anchoring', action='store_true',
                        help='Draw the map according to the anchoring (in seed frame).')
    options = parser.parse_args()
    print(f"using path: {options.path}")
    return options.path

class SpotMap():
    """ 
    Object that loads a map previously generated by spot and stores:
        self.graph - the graph protobuf
        self.waypoints - dict between waypoint ID and waypoint
        self.waypoint_snapshots - dict between waypoint ID and waypoint snapshot
        self.edge_snapshots - dict between edge ID and edge snapshot
        self.anchors - dict between anchor ID and anchor
        self.anchored_world_objects - dict between anchored world object ID and anchored world object
    """

    def __init__(self, path):
        # Set up maps from waypoint ID to waypoints, edges, snapshots, etc.
        self.graph = map_pb2.Graph()
        self.waypoints = {}
        self.waypoint_snapshots = {}
        self.edge_snapshots = {}
        self.anchors = {}
        self.anchored_world_objects = {}
        
        with open(os.path.join(path, 'graph'), 'rb') as graph_file:
            # Load the graph file and deserialize it. The graph file is a protobuf containing only the waypoints and the
            # edges between them.
            data = graph_file.read()
            self.graph.ParseFromString(data)

            # Load the anchored world objects first so we can look in each waypoint snapshot as we load it.
            for anchored_world_object in self.graph.anchoring.objects:
                self.anchored_world_objects[anchored_world_object.id] = (anchored_world_object,)
            # For each waypoint, load any snapshot associated with it.
            for waypoint in self.graph.waypoints:
                self.waypoints[waypoint.id] = waypoint

                if len(waypoint.snapshot_id) == 0:
                    continue
                # Load the snapshot. Note that snapshots contain all of the raw data in a waypoint and may be large.
                file_name = os.path.join(path, 'waypoint_snapshots', waypoint.snapshot_id)
                if not os.path.exists(file_name):
                    continue
                with open(file_name, 'rb') as snapshot_file:
                    waypoint_snapshot = map_pb2.WaypointSnapshot()
                    waypoint_snapshot.ParseFromString(snapshot_file.read())
                    self.waypoint_snapshots[waypoint_snapshot.id] = waypoint_snapshot

                    for fiducial in waypoint_snapshot.objects:
                        if not fiducial.HasField('apriltag_properties'):
                            continue

                        str_id = str(fiducial.apriltag_properties.tag_id)
                        if (str_id in self.anchored_world_objects and
                                len(self.anchored_world_objects[str_id]) == 1):

                            # Replace the placeholder tuple with a tuple of (wo, waypoint, fiducial).
                            anchored_wo = self.anchored_world_objects[str_id][0]
                            self.anchored_world_objects[str_id] = (anchored_wo, waypoint, fiducial)

            # Similarly, edges have snapshot data.
            for edge in self.graph.edges:
                if len(edge.snapshot_id) == 0:
                    continue
                file_name = os.path.join(path, 'edge_snapshots', edge.snapshot_id)
                if not os.path.exists(file_name):
                    continue
                with open(file_name, 'rb') as snapshot_file:
                    edge_snapshot = map_pb2.EdgeSnapshot()
                    edge_snapshot.ParseFromString(snapshot_file.read())
                    self.edge_snapshots[edge_snapshot.id] = edge_snapshot
            for anchor in self.graph.anchoring.anchors:
                self.anchors[anchor.id] = anchor
            print(
                f'Loaded graph with {len(self.graph.waypoints)} waypoints, {len(self.graph.edges)} edges, '
                f'{len(self.graph.anchoring.anchors)} anchors, and {len(self.graph.anchoring.objects)} anchored world objects'
            )


class BosdynVTKInterface():

    def create_fiducial_object(self,world_object, waypoint, renderer):
        """
        Creates a VTK object representing a fiducial.
        :param world_object: A WorldObject representing a fiducial.
        :param waypoint: The waypoint the AprilTag is associated with.
        :param renderer: The VTK renderer
        :return: a tuple of (vtkActor, 4x4 homogenous transform) representing the vtk actor for the fiducial, and its
        transform w.r.t the waypoint.
        """
        fiducial_object = world_object.apriltag_properties
        odom_tform_fiducial_filtered = get_a_tform_b(
            world_object.transforms_snapshot, ODOM_FRAME_NAME,
            world_object.apriltag_properties.frame_name_fiducial_filtered)
        waypoint_tform_odom = SE3Pose.from_proto(waypoint.waypoint_tform_ko)
        waypoint_tform_fiducial_filtered = api_to_vtk_se3_pose(
            waypoint_tform_odom * odom_tform_fiducial_filtered)
        plane_source = vtk.vtkPlaneSource()
        plane_source.SetCenter(0.0, 0.0, 0.0)
        plane_source.SetNormal(0.0, 0.0, 1.0)
        plane_source.Update()
        plane = plane_source.GetOutput()
        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputData(plane)

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)
        actor.GetProperty().SetColor(0.5, 0.7, 0.9)
        actor.SetScale(fiducial_object.dimensions.x, fiducial_object.dimensions.y, 1.0)
        renderer.AddActor(actor)
        return actor, waypoint_tform_fiducial_filtered


    def create_point_cloud_object(self,waypoints, snapshots, waypoint_id):
        """
        Create a VTK object representing the point cloud in a snapshot. Note that in graph_nav, "point cloud" refers to the
        feature cloud of a waypoint -- that is, a collection of visual features observed by all five cameras at a particular
        point in time. The visual features are associated with points that are rigidly attached to a waypoint.
        :param waypoints: dict of waypoint ID to waypoint.
        :param snapshots: dict of waypoint snapshot ID to waypoint snapshot.
        :param waypoint_id: the waypoint ID of the waypoint whose point cloud we want to render.
        :return: a vtkActor containing the point cloud data.
        """
        wp = waypoints[waypoint_id]
        snapshot = snapshots[wp.snapshot_id]
        cloud = snapshot.point_cloud
        odom_tform_cloud = get_a_tform_b(cloud.source.transforms_snapshot, ODOM_FRAME_NAME,
                                        cloud.source.frame_name_sensor)
        waypoint_tform_odom = SE3Pose.from_proto(wp.waypoint_tform_ko)
        waypoint_tform_cloud = api_to_vtk_se3_pose(waypoint_tform_odom * odom_tform_cloud)

        point_cloud_data = np.frombuffer(cloud.data, dtype=np.float32).reshape(int(cloud.num_points), 3)
        poly_data = numpy_to_poly_data(point_cloud_data)
        arr = vtk.vtkFloatArray()
        for i in range(cloud.num_points):
            arr.InsertNextValue(point_cloud_data[i, 2])
        arr.SetName('z_coord')
        poly_data.GetPointData().AddArray(arr)
        poly_data.GetPointData().SetActiveScalars('z_coord')
        actor = vtk.vtkActor()
        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputData(poly_data)
        mapper.ScalarVisibilityOn()
        actor.SetMapper(mapper)
        actor.GetProperty().SetPointSize(2)
        actor.SetUserTransform(waypoint_tform_cloud)
        return actor

    def create_waypoint_center_object(self,waypoints, snapshots, waypoint_id):
        """
        Create a VTK object representing the center of a waypoint as a sphere
        :param waypoints: dict of waypoint ID to waypoint.
        :param snapshots: dict of waypoint snapshot ID to waypoint snapshot.
        :param waypoint_id: the waypoint ID of the waypoint whose point cloud we want to render.
        :return: a vtkActor containing the center of the waypoint as a sphere
        """
        wp = waypoints[waypoint_id]
        snapshot = snapshots[wp.snapshot_id]
        cloud = snapshot.point_cloud
        odom_tform_cloud = get_a_tform_b(cloud.source.transforms_snapshot, ODOM_FRAME_NAME,
                                            cloud.source.frame_name_sensor)
        waypoint_tform_odom = SE3Pose.from_proto(wp.waypoint_tform_ko)
        waypoint_tform_cloud = api_to_vtk_se3_pose(waypoint_tform_odom * odom_tform_cloud)
        # print(f"waypoint_tform_cloud: {waypoint_tform_cloud}")
        sphere = vtk.vtkSphereSource()
        sphere.SetCenter(0.0,0.0,0.0) #set to origin, then transform later with SetUserTransform
        sphere.SetRadius(0.3)
        sphere.Update()

        sphere_mapper = vtk.vtkPolyDataMapper()
        sphere_mapper.SetInputConnection(sphere.GetOutputPort())
        sphere_actor = vtk.vtkActor()
        sphere_actor.SetMapper(sphere_mapper)
        sphere_actor.GetProperty().SetColor(1.0, 1.0, 1.0)
        sphere_actor.SetUserTransform(waypoint_tform_cloud)

        return sphere_actor

    def click_callback(self, obj, event):
        """
        Callback function for when a waypoint is clicked.
        :param obj: The VTK object that was clicked.
        :param event: The event that was triggered.
        :return: None.
        """
        # Get the waypoint ID from the clicked object.
        # waypoint_id = obj.GetMapper().GetInput().GetPointData().GetArray('waypoint_id').GetValue(0)
        # print(f'Clicked on waypoint {waypoint_id}')
        print("click_callback")

    def create_waypoint_object(self,renderer, waypoints, snapshots, waypoint_id):
        """
        Creates a VTK object representing a waypoint and its point cloud.
        :param renderer: The VTK renderer.
        :param waypoints: dict of waypoint ID to waypoint.
        :param snapshots: dict of snapshot ID to snapshot.
        :param waypoint_id: the waypoint id of the waypoint object we wish to create.
        :return: A vtkAssembly representing the waypoint (an axis) and its point cloud.
        """
        assembly = vtk.vtkAssembly()
        actor = vtk.vtkAxesActor()
        actor.SetXAxisLabelText('')
        actor.SetYAxisLabelText('')
        actor.SetZAxisLabelText('')
        actor.SetTotalLength(0.2, 0.2, 0.2)
        # point_cloud_actor = create_point_cloud_object(waypoints, snapshots, waypoint_id)
        sphere_center_actor = self.create_waypoint_center_object(waypoints, snapshots, waypoint_id)

        assembly.AddPart(actor)
        # assembly.AddPart(point_cloud_actor)
        assembly.AddPart(sphere_center_actor)

        renderer.AddActor(assembly)
        return assembly


    def make_line(self, pt_A, pt_B, renderer):
        """
        Creates a VTK object which is a white line between two points.
        :param pt_A: starting point of the line.
        :param pt_B: ending point of the line.
        :param renderer: the VTK renderer.
        :return: A VTK object that is a while line between pt_A and pt_B.
        """
        line_source = vtk.vtkLineSource()
        line_source.SetPoint1(pt_A[0], pt_A[1], pt_A[2])
        line_source.SetPoint2(pt_B[0], pt_B[1], pt_B[2])
        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(line_source.GetOutputPort())

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)
        actor.GetProperty().SetLineWidth(2)
        actor.GetProperty().SetColor(0.7, 0.7, 0.7)
        renderer.AddActor(actor)
        return actor


    def make_text(self, name, pt, renderer):
        """
        Creates white text on a black background at a particular point.
        :param name: The text to display.
        :param pt: The point in the world where the text will be displayed.
        :param renderer: The VTK renderer
        :return: the vtkActor representing the text.
        """
        actor = vtk.vtkTextActor()
        actor.SetInput(name)
        prop = actor.GetTextProperty()
        prop.SetBackgroundColor(0.0, 0.0, 0.0)
        prop.SetBackgroundOpacity(0.5)
        prop.SetFontSize(16)
        coord = actor.GetPositionCoordinate()
        coord.SetCoordinateSystemToWorld()
        coord.SetValue((pt[0], pt[1], pt[2]))

        renderer.AddActor(actor)
        return actor


    def create_edge_object(self, curr_wp_tform_to_wp, world_tform_curr_wp, renderer):
        # Concatenate the edge transform.
        world_tform_to_wp = np.dot(world_tform_curr_wp, curr_wp_tform_to_wp)
        # Make a line between the current waypoint and the neighbor.
        self.make_line(world_tform_curr_wp[:3, 3], world_tform_to_wp[:3, 3], renderer)
        return world_tform_to_wp



class MouseInteractorHighLightActor(vtkInteractorStyleTerrain):
    """ 
    Custom Interactor that allows the user to click on an actor and highlight it with a silhouette.
    """
    def __init__(self, silhouette=None, silhouetteActor=None):
        self.AddObserver("KeyPressEvent", self.onKeyPressEvent)

        # self.AddObserver("LeftButtonPressEvent", self.onLeftButtonDown)
        self.LastPickedActor = None
        self.Silhouette = silhouette
        self.SilhouetteActor = silhouetteActor

    def actorSelectedCallback(self, actor):
        # Get the actor from the graph and command spot to go
        pass 
    
    def onKeyPressEvent(self, obj, event):
        key = self.GetInteractor().GetKeySym()
        if key == 'space':
            click_x, click_y = self.GetInteractor().GetEventPosition()

            #  Pick from this location.
            picker = vtkPropPicker()
            picker.Pick(click_x, click_y, 0, self.GetDefaultRenderer())
            actor = picker.GetActor()

            if actor:
                self.actorSelectedCallback(actor)         

            self.LastPickedActor = actor

            # If we picked something before, remove the silhouette actor and
            # generate a new one.
            if self.LastPickedActor:
                self.GetDefaultRenderer().RemoveActor(self.SilhouetteActor)

                # Highlight the picked actor by generating a silhouette
                self.Silhouette.SetInputData(self.LastPickedActor.GetMapper().GetInput())
                self.GetDefaultRenderer().AddActor(self.SilhouetteActor)

            # render the image
            self.GetDefaultRenderer().GetRenderWindow().Render()
        #  Forward events
        self.OnKeyPress()
        return
            
    def SetSilhouette(self, silhouette):
        self.Silhouette = silhouette

    def SetSilhouetteActor(self, silhouetteActor):
        self.SilhouetteActor = silhouetteActor


class VTKEngine():
    numberOfSpheres = 10
    path = get_program_parameters()
    spot_map = SpotMap(path)

    colors = vtkNamedColors()

    # A renderer and render window
    renderer = vtkRenderer()
    renderer.SetBackground(colors.GetColor3d('SteelBlue'))

    renderWindow = vtkRenderWindow()
    renderWindow.SetSize(640, 480)
    renderWindow.AddRenderer(renderer)

    # An interactor
    interactor = vtkRenderWindowInteractor()
    interactor.SetRenderWindow(renderWindow)

    randomSequence = vtkMinimalStandardRandomSequence()
    # randomSequence.SetSeed(1043618065)
    # randomSequence.SetSeed(5170)
    randomSequence.SetSeed(8775070)
    # Add spheres to play with
    for i in range(numberOfSpheres):
        source = vtkSphereSource()

        # random position and radius
        x = randomSequence.GetRangeValue(-5.0, 5.0)
        randomSequence.Next()
        y = randomSequence.GetRangeValue(-5.0, 5.0)
        randomSequence.Next()
        z = randomSequence.GetRangeValue(-5.0, 5.0)
        randomSequence.Next()
        radius = randomSequence.GetRangeValue(0.5, 1.0)
        randomSequence.Next()

        source.SetRadius(radius)
        source.SetCenter(x, y, z)
        source.SetPhiResolution(11)
        source.SetThetaResolution(21)

        mapper = vtkPolyDataMapper()
        mapper.SetInputConnection(source.GetOutputPort())
        actor = vtkActor()
        actor.SetMapper(mapper)

        r = randomSequence.GetRangeValue(0.4, 1.0)
        randomSequence.Next()
        g = randomSequence.GetRangeValue(0.4, 1.0)
        randomSequence.Next()
        b = randomSequence.GetRangeValue(0.4, 1.0)
        randomSequence.Next()

        actor.GetProperty().SetDiffuseColor(r, g, b)
        actor.GetProperty().SetDiffuse(0.8)
        actor.GetProperty().SetSpecular(0.5)
        actor.GetProperty().SetSpecularColor(colors.GetColor3d('White'))
        actor.GetProperty().SetSpecularPower(30.0)

        renderer.AddActor(actor)

    # Render and interact
    renderWindow.Render()

    # Create the silhouette pipeline, the input data will be set in the
    # interactor
    silhouette = vtkPolyDataSilhouette()
    silhouette.SetCamera(renderer.GetActiveCamera())

    # Create mapper and actor for silhouette
    silhouetteMapper = vtkPolyDataMapper()
    silhouetteMapper.SetInputConnection(silhouette.GetOutputPort())

    silhouetteActor = vtkActor()
    silhouetteActor.SetMapper(silhouetteMapper)
    silhouetteActor.GetProperty().SetColor(colors.GetColor3d("Tomato"))
    silhouetteActor.GetProperty().SetLineWidth(5)

    # Set the custom type to use for interaction.
    style = MouseInteractorHighLightActor(silhouette, silhouetteActor)
    style.SetDefaultRenderer(renderer)

    # Start
    interactor.Initialize()
    interactor.SetInteractorStyle(style)
    renderWindow.SetWindowName('HighlightWithSilhouette')
    renderWindow.Render()

    interactor.Start()

   
def main():
    engine = VTKEngine()

if __name__ == "__main__":
    main()